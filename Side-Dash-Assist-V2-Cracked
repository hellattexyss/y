-- ============ SNIPPET 1: CORE LOGIC ============

local plrs = game:GetService("Players")
local run = game:GetService("RunService")
local input = game:GetService("UserInputService")
local tween = game:GetService("TweenService")
local http = game:GetService("HttpService")
local ws = workspace
local lp = plrs.LocalPlayer
local cam = ws.CurrentCamera

-- INITIALIZE scriptEnabled HERE (before anything uses it!)
local scriptEnabled = true

math.randomseed(tick() % 65536)
local char = lp.Character or lp.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")
local hum = char:FindFirstChildOfClass("Humanoid")

local function isDead()
	if not hum or not hum.Parent then return false end
	if hum.Health <= 0 then return true end
	if hum.PlatformStand then return true end
	local ok, state = pcall(function() return hum:GetState() end)
	if ok and state == Enum.HumanoidStateType.Physics then return true end
	local ragdoll = char:FindFirstChild("Ragdoll")
	if ragdoll and ragdoll:IsA("BoolValue") and ragdoll.Value then return true end
	return false
end

lp.CharacterAdded:Connect(function(newChar)
	char = newChar
	hrp = newChar:WaitForChild("HumanoidRootPart")
	hum = newChar:FindFirstChildOfClass("Humanoid")
end)

local animIds = {
	[10449761463] = {Left = 10480796021, Right = 10480793962, Straight = 10479335397},
	[13076380114] = {Left = 101843860692381, Right = 100087324592640, Straight = 110878031211717},
}
local gameAnims = animIds[game.PlaceId] or animIds[13076380114]
local leftId, rightId, straightId = gameAnims.Left, gameAnims.Right, gameAnims.Straight

local dashRange = 40
local minGap, maxGap = 1.2, 60
local targetDist = 15
local straightSpeed = 120
local aspect = 390 / 480
local dashSfxId = "rbxassetid://72014632956520"

local isDashing = false
local sideAnim = nil
local lastDash = -math.huge
local dashSfx = Instance.new("Sound")
dashSfx.Name = "DashSFX"
dashSfx.SoundId = dashSfxId
dashSfx.Volume = 2
dashSfx.Looped = false
dashSfx.Parent = ws

local autoRotateHook, shouldDisableRot = nil, false

local function hookAutoRotate()
	if autoRotateHook then pcall(function() autoRotateHook:Disconnect() end) autoRotateHook = nil end
	local h = char and char:FindFirstChildOfClass("Humanoid")
	if not h then return end
	autoRotateHook = h:GetPropertyChangedSignal("AutoRotate"):Connect(function()
		if shouldDisableRot then
			pcall(function() if h and h.AutoRotate then h.AutoRotate = false end end)
		end
	end)
end
hookAutoRotate()
lp.CharacterAdded:Connect(function() task.wait(0.05) hookAutoRotate() end)

local function angleDiff(a, b)
	local d = a - b
	while d > math.pi do d = d - 2 * math.pi end
	while d < -math.pi do d = d + 2 * math.pi end
	return d
end

local function easeCubic(x)
	x = math.clamp(x, 0, 1)
	return 1 - (1 - x) ^ 3
end

local function getHumAndAnim()
	if not char or not char.Parent then return nil, nil end
	local h = char:FindFirstChildOfClass("Humanoid")
	if not h then return nil, nil end
	local anim = h:FindFirstChildOfClass("Animator") or Instance.new("Animator")
	if not anim.Parent then anim.Name = "Animator" anim.Parent = h end
	return h, anim
end

local function playSideAnim(isLeft)
	pcall(function() if sideAnim and sideAnim.IsPlaying then sideAnim:Stop() end end)
	sideAnim = nil
	local h, animator = getHumAndAnim()
	if not h or not animator then return end
	local id = isLeft and leftId or rightId
	if not id then return end
	local anim = Instance.new("Animation")
	anim.Name = "SideAnim"
	anim.AnimationId = "rbxassetid://" .. tostring(id)
	local ok, track = pcall(function() return animator:LoadAnimation(anim) end)
	if not ok or not track then anim:Destroy() return end
	sideAnim = track
	track.Priority = Enum.AnimationPriority.Action
	pcall(function() track.Looped = false end)
	track:Play()
	pcall(function() dashSfx:Stop() dashSfx:Play() end)
	delay(0.6, function()
		pcall(function() if track and track.IsPlaying then track:Stop() end end)
		pcall(function() anim:Destroy() end)
	end)
end

local function findTarget(range)
	range = range or dashRange
	local closest, best = nil, math.huge
	if not hrp then return nil end
	local myPos = hrp.Position
	for _, pl in ipairs(plrs:GetPlayers()) do
		if pl ~= lp and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") and pl.Character:FindFirstChild("Humanoid") then
			local hum2 = pl.Character.Humanoid
			if hum2.Health > 0 then
				local d = (pl.Character.HumanoidRootPart.Position - myPos).Magnitude
				if d < best and d <= range then closest, best = pl.Character, d end
			end
		end
	end
	for _, m in ipairs(ws:GetDescendants()) do
		if m:IsA("Model") and m:FindFirstChild("Humanoid") and m:FindFirstChild("HumanoidRootPart") and not plrs:GetPlayerFromCharacter(m) then
			local hum2 = m.Humanoid
			if hum2.Health > 0 then
				local d = (m.HumanoidRootPart.Position - myPos).Magnitude
				if d < best and d <= range then closest, best = m, d end
			end
		end
	end
	return closest, best
end

local function getDashDuration(val)
	return 1.5 + (0.12 - 1.5) * math.clamp(val or 100, 0, 100) / 100
end
local function getDashAngle(val) return 90 + 990 * math.clamp(val or 56, 0, 100) / 100 end
local function getDashDist(val) return 1 + 11 * math.clamp(val or 50, 0, 100) / 100 end

local selectedTarget = nil
plrs.PlayerRemoving:Connect(function(p) if selectedTarget == p then selectedTarget = nil end end)

local function getCurrentTarget()
	if selectedTarget and selectedTarget.Character and selectedTarget.Character.Parent then
		local ch = selectedTarget.Character
		local tHrp = ch:FindFirstChild("HumanoidRootPart")
		local tHum = ch:FindFirstChildOfClass("Humanoid")
		if tHrp and tHum and tHum.Health > 0 and hrp and (tHrp.Position - hrp.Position).Magnitude <= dashRange then
			return ch
		end
	end
	selectedTarget = nil
	return findTarget(dashRange)
end

local function straightDash(target, speed)
	if not speed then speed = straightSpeed end
	if not target or not target.Parent or not hrp or not hrp.Parent then return end
	local attach = Instance.new("Attachment")
	attach.Parent = hrp
	local vel = Instance.new("LinearVelocity")
	vel.Attachment0 = attach
	vel.MaxForce = math.huge
	vel.RelativeTo = Enum.ActuatorRelativeTo.World
	vel.Parent = hrp
	local reached, active = false, true
	local conn
	conn = run.Heartbeat:Connect(function()
		if not active or not target or not target.Parent or not hrp or not hrp.Parent then
			active = false
			conn:Disconnect()
			pcall(function() vel:Destroy() attach:Destroy() end)
			return
		end
		local diff = target.Position - hrp.Position
		local flat = Vector3.new(diff.X, 0, diff.Z)
		if flat.Magnitude <= targetDist then
			reached, active = true, false
			conn:Disconnect()
			pcall(function() vel:Destroy() attach:Destroy() end)
			return
		end
		vel.VectorVelocity = flat.Unit * speed
		pcall(function() if flat.Magnitude > 0.001 then hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + flat.Unit) end end)
	end)
	while not reached and target and target.Parent and hrp and hrp.Parent do task.wait() end
end

local sliderVals, savedSettings = {}, nil
local attr = lp:GetAttribute("SettingsV2")
if type(attr) == "string" then
	pcall(function()
		savedSettings = http:JSONDecode(attr)
		if savedSettings and savedSettings.Sliders then
			for n, v in pairs(savedSettings.Sliders) do
				local num = tonumber(v)
				if num then sliderVals[n] = math.clamp(math.floor(num), 0, 100) end
			end
		end
	end)
end

local function sendComm(data)
	pcall(function()
		local c = lp.Character
		if c and c:FindFirstChild("Communicate") then
			c.Communicate:FireServer(unpack(data))
		end
	end)
end

local m1Enabled, dashEnabled = false, false
local dashButtonGui = nil

-- END SNIPPET 1
-- ============ SNIPPET 2: GUI ============

local settingsGuiModern = Instance.new("ScreenGui")
settingsGuiModern.Name = "SideDashAssistGUI"
settingsGuiModern.ResetOnSpawn = false
settingsGuiModern.Parent = lp:WaitForChild("PlayerGui")

local function makeDraggable(gui)
	local dragging = false
	local dragStart, startPos, currentInput
	gui.InputBegan:Connect(function(inp)
		if (inp.UserInputType == Enum.UserInputType.Touch or inp.UserInputType == Enum.UserInputType.MouseButton1) and not dragging then
			dragging = true
			dragStart = inp.Position
			startPos = gui.Position
			currentInput = inp
			inp.Changed:Connect(function()
				if inp.UserInputState == Enum.UserInputState.End then dragging, currentInput = false, nil end
			end)
		end
	end)
	input.InputChanged:Connect(function(inp)
		if dragging and currentInput == inp and (inp.UserInputType == Enum.UserInputType.Touch or inp.UserInputType == Enum.UserInputType.MouseMovement) then
			local delta = inp.Position - dragStart
			gui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end)
end

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 380, 0, 140)
mainFrame.Position = UDim2.new(0.5, -190, 0.12, 0)
mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = settingsGuiModern
makeDraggable(mainFrame)

Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 20)
local mainBgGradient = Instance.new("UIGradient")
mainBgGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 5, 5)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(15, 15, 15)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
})
mainBgGradient.Rotation = 90
mainBgGradient.Parent = mainFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(0, 200, 0, 30)
titleLabel.Position = UDim2.new(0, 20, 0, 10)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Side Dash Assist"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 23
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = mainFrame

local authorLabel = Instance.new("TextLabel")
authorLabel.Size = UDim2.new(1, -40, 0, 17)
authorLabel.Position = UDim2.new(0, 20, 0, 32)
authorLabel.BackgroundTransparency = 1
authorLabel.Text = "by CPS Network"
authorLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
authorLabel.TextSize = 13
authorLabel.Font = Enum.Font.GothamMedium
authorLabel.TextXAlignment = Enum.TextXAlignment.Left
authorLabel.Parent = mainFrame

local minimizeBtn = Instance.new("TextButton")
minimizeBtn.Size = UDim2.new(0, 35, 0, 35)
minimizeBtn.Position = UDim2.new(1, -85, 0, 7)
minimizeBtn.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
minimizeBtn.Text = "-"
minimizeBtn.Font = Enum.Font.GothamBold
minimizeBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
minimizeBtn.TextSize = 19
minimizeBtn.BorderSizePixel = 0
minimizeBtn.Parent = mainFrame
Instance.new("UICorner", minimizeBtn).CornerRadius = UDim.new(0, 10)

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 35, 0, 35)
closeBtn.Position = UDim2.new(1, -45, 0, 7)
closeBtn.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
closeBtn.Text = "X"
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
closeBtn.TextSize = 19
closeBtn.BorderSizePixel = 0
closeBtn.Parent = mainFrame
Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 10)

local buttonContainer = Instance.new("Frame")
buttonContainer.Size = UDim2.new(0, 200, 0, 48)
buttonContainer.Position = UDim2.new(0.5, -100, 0, 72)
buttonContainer.BackgroundTransparency = 1
buttonContainer.Parent = mainFrame

local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(1, 0, 1, 0)
toggleButton.BackgroundTransparency = 1
toggleButton.BorderSizePixel = 0
toggleButton.Text = "Disable: OFF"
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.TextSize = 20
toggleButton.Font = Enum.Font.GothamBold
toggleButton.AutoButtonColor = false
toggleButton.Parent = buttonContainer

local buttonBg = Instance.new("Frame")
buttonBg.Size = UDim2.new(1, 0, 1, 0)
buttonBg.BackgroundColor3 = Color3.fromRGB(180, 13, 19)
buttonBg.BorderSizePixel = 0
buttonBg.Parent = buttonContainer
Instance.new("UICorner", buttonBg).CornerRadius = UDim.new(0, 12)

local buttonBorder = Instance.new("UIStroke")
buttonBorder.Color = Color3.fromRGB(255, 0, 0)
buttonBorder.Thickness = 2
buttonBorder.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
buttonBorder.Parent = buttonBg

-- OPEN GUI BUTTON (minimized)
local openGuiBtn = Instance.new("TextButton")
openGuiBtn.Size = UDim2.new(0, 40, 0, 40)
openGuiBtn.Position = UDim2.new(0, 10, 0.5, -20)
openGuiBtn.BackgroundColor3 = Color3.fromRGB(200, 0, 0)
openGuiBtn.Text = "â‰¡"
openGuiBtn.Font = Enum.Font.GothamBold
openGuiBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
openGuiBtn.TextSize = 24
openGuiBtn.BorderSizePixel = 0
openGuiBtn.Parent = settingsGuiModern
openGuiBtn.Visible = false
Instance.new("UICorner", openGuiBtn).CornerRadius = UDim.new(0, 8)
makeDraggable(openGuiBtn)

-- BUTTON CLICKS
toggleButton.MouseButton1Click:Connect(function()
	scriptEnabled = not scriptEnabled
	if scriptEnabled then
		toggleButton.Text = "Disable: OFF"
		buttonBorder.Color = Color3.fromRGB(255, 0, 0)
		buttonBg.BackgroundColor3 = Color3.fromRGB(180, 13, 19)
		if dashButtonGui then dashButtonGui.Enabled = true end
	else
		toggleButton.Text = "Enable: ON"
		buttonBorder.Color = Color3.fromRGB(110, 110, 110)
		buttonBg.BackgroundColor3 = Color3.fromRGB(54, 54, 54)
		if dashButtonGui then dashButtonGui.Enabled = false end
	end
end)

minimizeBtn.MouseButton1Click:Connect(function()
	mainFrame.Visible = false
	openGuiBtn.Visible = true
end)

closeBtn.MouseButton1Click:Connect(function()
	mainFrame.Visible = false
end)

openGuiBtn.MouseButton1Click:Connect(function()
	mainFrame.Visible = true
	openGuiBtn.Visible = false
end)

-- END SNIPPET 2
-- ============ SNIPPET 3: RED CIRCLE + DASH ============

dashButtonGui = Instance.new("ScreenGui")
dashButtonGui.Name = "DashButtonGUI"
dashButtonGui.ResetOnSpawn = false
dashButtonGui.Parent = lp:WaitForChild("PlayerGui")
dashButtonGui.Enabled = true

local dashButtonFrame = Instance.new("Frame")
dashButtonFrame.Name = "DashButton"
dashButtonFrame.Size = UDim2.new(0, 130, 0, 150)
dashButtonFrame.Position = UDim2.new(0, 20, 0, 20)
dashButtonFrame.BackgroundTransparency = 1
dashButtonFrame.BorderSizePixel = 0
dashButtonFrame.Parent = dashButtonGui

-- ICON LABEL (above circle)
local iconLabel = Instance.new("ImageLabel")
iconLabel.Name = "Icon"
iconLabel.Size = UDim2.new(0, 60, 0, 60)
iconLabel.Position = UDim2.new(0.5, -30, 0, 0)
iconLabel.BackgroundTransparency = 1
iconLabel.Image = "rbxassetid://110530089410634"
iconLabel.Parent = dashButtonFrame

local iconStroke = Instance.new("UIStroke")
iconStroke.Color = Color3.fromRGB(0, 0, 0)
iconStroke.Thickness = 2
iconStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
iconStroke.Parent = iconLabel

-- RED CIRCLE
local redCircle = Instance.new("Frame")
redCircle.Name = "RedCircle"
redCircle.Size = UDim2.new(0, 120, 0, 120)
redCircle.Position = UDim2.new(0.5, -60, 0, 60)
redCircle.BackgroundColor3 = Color3.fromRGB(220, 0, 0)
redCircle.BorderSizePixel = 0
redCircle.Parent = dashButtonFrame

Instance.new("UICorner", redCircle).CornerRadius = UDim.new(1, 0)

local glow = Instance.new("UIStroke")
glow.Color = Color3.fromRGB(255, 80, 60)
glow.Thickness = 3
glow.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
glow.Parent = redCircle

local grad = Instance.new("UIGradient")
grad.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 120, 100)),
	ColorSequenceKeypoint.new(0.3, Color3.fromRGB(240, 60, 40)),
	ColorSequenceKeypoint.new(0.7, Color3.fromRGB(210, 10, 20)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(150, 0, 0))
})
grad.Rotation = 90
grad.Parent = redCircle

-- TOUCH/DRAG
local dragging = false
local dragStart, startPos, dragInput
local activeTouches = {}

redCircle.InputBegan:Connect(function(inp)
	if inp.UserInputType == Enum.UserInputType.Touch or inp.UserInputType == Enum.UserInputType.MouseButton1 then
		activeTouches[inp] = true
		local count = 0
		for _ in pairs(activeTouches) do count = count + 1 end
		if count == 1 and not dragging then
			dragging = true
			dragStart = inp.Position
			startPos = dashButtonFrame.Position
			dragInput = inp
		end
	end
end)

input.InputChanged:Connect(function(inp)
	if dragging and dragInput == inp and (inp.UserInputType == Enum.UserInputType.Touch or inp.UserInputType == Enum.UserInputType.MouseMovement) then
		local delta = inp.Position - dragStart
		if delta.Magnitude > 5 then
			dashButtonFrame.Position = UDim2.new(
				0, math.clamp(startPos.X.Offset + delta.X, 0, cam.ViewportSize.X - dashButtonFrame.AbsoluteSize.X),
				0, math.clamp(startPos.Y.Offset + delta.Y, 0, cam.ViewportSize.Y - dashButtonFrame.AbsoluteSize.Y)
			)
		end
	end
end)

input.InputEnded:Connect(function(inp)
	activeTouches[inp] = nil
	if inp == dragInput and dragging then
		local moved = (inp.Position - dragStart).Magnitude > 8
		if not moved and tick() - lastDash >= 2 and scriptEnabled and not isDead() then
			local target = getCurrentTarget()
			if target then circularDash(target) end
		end
		dragging, dragInput = false, nil
	end
end)

-- KEYBOARD INPUT
input.InputBegan:Connect(function(inp, gp)
	if gp or isDashing or not scriptEnabled or isDead() then return end
	local key = input.GamepadEnabled and Enum.KeyCode.DPadUp or Enum.KeyCode.G
	local shouldDash = false
	if inp.UserInputType == Enum.UserInputType.Keyboard and (inp.KeyCode == Enum.KeyCode.X or inp.KeyCode == key) then
		shouldDash = true
	end
	if (inp.UserInputType == Enum.UserInputType.Gamepad1 or inp.UserInputType == Enum.UserInputType.Gamepad2 or inp.UserInputType == Enum.UserInputType.Gamepad3 or inp.UserInputType == Enum.UserInputType.Gamepad4)
		and inp.KeyCode == Enum.KeyCode.DPadUp then
		shouldDash = true
	end
	if inp.UserInputType == Enum.UserInputType.MouseButton1 and inp.Target and inp.Target:IsDescendantOf(redCircle) then
		shouldDash = true
	end
	if shouldDash then
		local target = getCurrentTarget()
		if target then circularDash(target) end
	end
end)

-- CIRCULAR DASH FUNCTION
function circularDash(target)
	if isDashing or not target or not target:FindFirstChild("HumanoidRootPart") or not hrp then return end
	isDashing = true

	local h = char:FindFirstChildOfClass("Humanoid")
	local oldRot = h and h.AutoRotate
	if h then
		shouldDisableRot = true
		pcall(function() h.AutoRotate = false end)
	end
	local function restore()
		if h and oldRot ~= nil then
			shouldDisableRot = false
			pcall(function() h.AutoRotate = oldRot end)
		end
	end

	local speedVal = sliderVals["Dash speed"] or 100
	local angleVal = sliderVals["Dash Degrees"] or 56
	local gapVal = sliderVals["Dash gap"] or 50

	local duration = getDashDuration(speedVal)
	local angle = math.rad(getDashAngle(angleVal))
	local gap = math.clamp(getDashDist(gapVal), minGap, maxGap)

	local targetHrp = target.HumanoidRootPart
	if (targetHrp.Position - hrp.Position).Magnitude >= targetDist then
		straightDash(targetHrp, straightSpeed)
	end
	if not targetHrp or not targetHrp.Parent or not hrp or not hrp.Parent then
		restore()
		isDashing = false
		return
	end

	local targetPos = targetHrp.Position
	local myPos = hrp.Position
	local right = hrp.CFrame.RightVector
	local dir = targetPos - myPos
	if dir.Magnitude < 0.001 then dir = hrp.CFrame.LookVector end
	local isLeft = right:Dot(dir.Unit) < 0
	playSideAnim(isLeft)
	local dirMult = isLeft and 1 or -1

	local startAngle = math.atan2(targetPos.Z - myPos.Z, targetPos.X - myPos.X)
	local startDist = math.clamp((Vector3.new(targetPos.X, 0, targetPos.Z) - Vector3.new(myPos.X, 0, myPos.Z)).Magnitude, minGap, maxGap)

	local start = tick()
	local conn
	local aimed, finished, canEnd, endQueued = false, false, false, false

	local function cleanup()
		if finished then return end
		finished = true
		task.delay(0.7, function()
			canEnd = true
			if endQueued then isDashing = false end
		end)
		restore()
		lastDash = tick()
	end

	if m1Enabled then
		sendComm({{Mobile = true, Goal = "LeftClick"}})
		task.delay(0.05, function() sendComm({{Goal = "LeftClickRelease", Mobile = true}}) end)
	end
	if dashEnabled then
		sendComm({{Dash = Enum.KeyCode.W, Key = Enum.KeyCode.Q, Goal = "KeyPress"}})
	end

	conn = run.Heartbeat:Connect(function()
		local t = math.clamp((tick() - start) / duration, 0, 1)
		local e = easeCubic(t)
		local curDist = math.clamp(startDist + (gap - startDist) * easeCubic(math.clamp(t * 1.5, 0, 1)), minGap, maxGap)
		local curAngle = startAngle + dirMult * angle * easeCubic(t)
		local targetCurrentPos = targetHrp.Position
		local nextPos = Vector3.new(
			targetCurrentPos.X + curDist * math.cos(curAngle),
			targetCurrentPos.Y,
			targetCurrentPos.Z + curDist * math.sin(curAngle)
		)
		local lookTarget = targetCurrentPos or nextPos
		local lookAngle = math.atan2((lookTarget - nextPos).Z, (lookTarget - nextPos).X)
		local camAngle = math.atan2(hrp.CFrame.LookVector.Z, hrp.CFrame.LookVector.X)
		local finalAngle = camAngle + angleDiff(lookAngle, camAngle) * 0.7
		pcall(function()
			hrp.CFrame = CFrame.new(nextPos, nextPos + Vector3.new(math.cos(finalAngle), 0, math.sin(finalAngle)))
		end)
		if not aimed and aspect <= e then
			aimed = true
			cleanup()
		end
		if t >= 1 then
			conn:Disconnect()
			pcall(function() if sideAnim and sideAnim.IsPlaying then sideAnim:Stop() end sideAnim = nil end)
			if not aimed then aimed = true cleanup() end
			endQueued = true
			if canEnd then isDashing = false end
		end
	end)
end

-- END SNIPPET 3
