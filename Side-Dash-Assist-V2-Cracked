-- Side Dash Assist v1.0 by CPS Network
-- SNIPPET 1: All dash/target logic, settings integration

local plrs = game:GetService("Players")
local run = game:GetService("RunService")
local input = game:GetService("UserInputService")
local tween = game:GetService("TweenService")
local ws = workspace
local lp = plrs.LocalPlayer
local cam = ws.CurrentCamera

math.randomseed(tick() % 65536)
local char = lp.Character or lp.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")
local hum = char:FindFirstChildOfClass("Humanoid")
local selectedTarget = nil

local function isDead()
	if not hum or not hum.Parent then return false end
	if hum.Health <= 0 then return true end
	if hum.PlatformStand then return true end
	local success, state = pcall(function() return hum:GetState() end)
	if success and state == Enum.HumanoidStateType.Physics then return true end
	local ragdoll = char:FindFirstChild("Ragdoll")
	if ragdoll and ragdoll:IsA("BoolValue") and ragdoll.Value then return true end
	return false
end

lp.CharacterAdded:Connect(function(newChar)
	char = newChar
	hrp = newChar:WaitForChild("HumanoidRootPart")
	hum = newChar:FindFirstChildOfClass("Humanoid")
end)

local animIds = {
	[10449761463] = {Left = 10480796021, Right = 10480793962, Straight = 10479335397},
	[13076380114] = {Left = 101843860692381, Right = 100087324592640, Straight = 110878031211717},
}
local gameAnims = animIds[game.PlaceId] or animIds[13076380114]
local leftId, rightId, straightId = gameAnims.Left, gameAnims.Right, gameAnims.Straight

local dashRange = 40
local minGap = 1.2
local maxGap = 60
local targetDist = 15
local straightSpeed = 120
local aspect = 390 / 480
local dashSfxId = "rbxassetid://72014632956520"
local isDashing = false
local sideAnim, lastDash = nil, -math.huge

local dashSfx = Instance.new("Sound")
dashSfx.Name = "DashSFX"
dashSfx.SoundId = dashSfxId
dashSfx.Volume = 2
dashSfx.Looped = false
dashSfx.Parent = ws

local sliderVals = {["Dash speed"]=49,["Dash Degrees"]=32,["Dash gap"]=14}
local m1Enabled, dashEnabled = true, false

local function sendComm(data)
	pcall(function()
		local char = lp.Character
		if char and char:FindFirstChild("Communicate") then
			char.Communicate:FireServer(unpack(data))
		end
	end)
end

local function findTarget(range)
	range = range or dashRange
	local closest, closestDist = nil, math.huge
	if not hrp then return nil end
	local myPos = hrp.Position
	for _, player in pairs(plrs:GetPlayers()) do
		if player ~= lp and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local targetHum = player.Character:FindFirstChild("Humanoid")
			if targetHum and targetHum.Health > 0 then
				local dist = (player.Character.HumanoidRootPart.Position - myPos).Magnitude
				if dist < closestDist and dist <= range then
					closest, closestDist = player.Character, dist
				end
			end
		end
	end
	for _, model in pairs(ws:GetDescendants()) do
		if model:IsA("Model") and model:FindFirstChild("Humanoid") and model:FindFirstChild("HumanoidRootPart") and not plrs:GetPlayerFromCharacter(model) then
			local targetHum = model.Humanoid
			if targetHum and targetHum.Health > 0 then
				local dist = (model.HumanoidRootPart.Position - myPos).Magnitude
				if dist < closestDist and dist <= range then
					closest, closestDist = model, dist
				end
			end
		end
	end
	return closest, closestDist
end

plrs.PlayerRemoving:Connect(function(p) if selectedTarget == p then selectedTarget = nil end end)
local function getCurrentTarget()
	if selectedTarget and selectedTarget.Character and selectedTarget.Character.Parent then
		local tChar = selectedTarget.Character
		local tHrp = tChar:FindFirstChild("HumanoidRootPart")
		local tHum = tChar:FindFirstChildOfClass("Humanoid")
		if tHrp and tHum and tHum.Health > 0 and hrp then
			if (tHrp.Position - hrp.Position).Magnitude <= dashRange then return tChar end
		end
	end
	selectedTarget = nil
	return findTarget(dashRange)
end

local function getDashDuration(val)
	return 1.5 + (0.12 - 1.5) * (val or sliderVals["Dash speed"] or 49) / 100
end
local function getDashAngle(val)
	return 90 + 990 * (val or sliderVals["Dash Degrees"] or 32) / 100
end
local function getDashDist(val)
	return 1 + 11 * (val or sliderVals["Dash gap"] or 14) / 100
end

local function playSideAnim(isLeft)
	pcall(function() if sideAnim and sideAnim.IsPlaying then sideAnim:Stop() end end)
	sideAnim = nil
	local h = char:FindFirstChildOfClass("Humanoid")
	local animator = h and (h:FindFirstChildOfClass("Animator") or Instance.new("Animator", h))
	local id = isLeft and leftId or rightId
	if not h or not animator or not id then return end
	local anim = Instance.new("Animation")
	anim.Name = "SideAnim"
	anim.AnimationId = "rbxassetid://" .. tostring(id)
	local success, track = pcall(function() return animator:LoadAnimation(anim) end)
	if not success or not track then anim:Destroy() return end
	sideAnim = track
	track.Priority = Enum.AnimationPriority.Action
	pcall(function() track.Looped = false end)
	track:Play()
	pcall(function() dashSfx:Stop() dashSfx:Play() end)
	delay(0.6, function() pcall(function() if track and track.IsPlaying then track:Stop() end end) pcall(function() anim:Destroy() end) end)
end

local function straightDash(target, speed)
	if not speed then speed = straightSpeed end
	if not target or not target.Parent or not hrp or not hrp.Parent then return end
	local attach = Instance.new("Attachment")
	attach.Name = "DashAttach"
	attach.Parent = hrp
	local vel = Instance.new("LinearVelocity")
	vel.Name = "DashVelocity"
	vel.Attachment0 = attach
	vel.MaxForce = math.huge
	vel.RelativeTo = Enum.ActuatorRelativeTo.World
	vel.Parent = hrp
	local h = char:FindFirstChildOfClass("Humanoid")
	local animTrack, animObj = nil, nil
	if straightId and h and h:FindFirstChildOfClass("Animator") then
		animObj = Instance.new("Animation")
		animObj.Name = "StraightAnim"
		animObj.AnimationId = "rbxassetid://" .. tostring(straightId)
		local track = h:FindFirstChildOfClass("Animator"):LoadAnimation(animObj)
		if track then
			animTrack = track
			track.Priority = Enum.AnimationPriority.Movement
			pcall(function() track.Looped = false end)
			track:Play()
		end
	end
	local conn
	conn = run.Heartbeat:Connect(function()
		if not target or not target.Parent or not hrp or not hrp.Parent then
			conn:Disconnect() vel:Destroy() attach:Destroy() if animTrack then animTrack:Stop() end if animObj then animObj:Destroy() end return
		end
		local targetPos = target.Position
		local diff = targetPos - hrp.Position
		local flatDiff = Vector3.new(diff.X, 0, diff.Z)
		if flatDiff.Magnitude <= targetDist then
			conn:Disconnect() vel:Destroy() attach:Destroy() if animTrack then animTrack:Stop() end if animObj then animObj:Destroy() end return
		end
		vel.VectorVelocity = flatDiff.Unit * speed
		pcall(function() if flatDiff.Magnitude > 0.001 then hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + flatDiff.Unit) end end)
	end)
end

local function circularDash(target)
	if isDashing or not target or not target:FindFirstChild("HumanoidRootPart") or not hrp then return end
	isDashing = true
	local h = char:FindFirstChildOfClass("Humanoid")
	local oldRot = h and h.AutoRotate
	if h then h.AutoRotate = false end
	local restore = function() if h and oldRot ~= nil then h.AutoRotate = oldRot end end
	local speedVal = sliderVals["Dash speed"] or 49
	local angleVal = sliderVals["Dash Degrees"] or 32
	local gapVal = sliderVals["Dash gap"] or 14
	local duration = getDashDuration(speedVal)
	local angle = math.rad(getDashAngle(angleVal))
	local gap = math.clamp(getDashDist(gapVal), minGap, maxGap)
	local targetHrp = target.HumanoidRootPart
	if (targetHrp.Position - hrp.Position).Magnitude >= targetDist then straightDash(targetHrp, straightSpeed) end
	if not targetHrp or not targetHrp.Parent or not hrp or not hrp.Parent then restore() isDashing = false return end
	local targetPos = targetHrp.Position
	local myPos = hrp.Position
	local right = hrp.CFrame.RightVector
	local dir = targetPos - myPos
	if dir.Magnitude < 0.001 then dir = hrp.CFrame.LookVector end
	local isLeft = right:Dot(dir.Unit) < 0
	playSideAnim(isLeft)
	local dirMult = isLeft and 1 or -1
	local startAngle = math.atan2(targetPos.Z - myPos.Z, targetPos.X - myPos.X)
	local startDist = math.clamp((Vector3.new(targetPos.X, 0, targetPos.Z) - Vector3.new(myPos.X, 0, myPos.Z)).Magnitude, minGap, maxGap)
	local start = tick()
	local conn, aimed, finished, canEnd, endQueued = nil, false, false, false, false
	local function cleanup() if finished then return end finished = true task.delay(0.7, function() canEnd = true if endQueued then isDashing = false end end) restore() lastDash = tick() end
	if m1Enabled then sendComm({{Mobile = true, Goal = "LeftClick"}}) task.delay(0.05, function() sendComm({{Goal = "LeftClickRelease", Mobile = true}}) end) end
	if dashEnabled then sendComm({{Dash = Enum.KeyCode.W, Key = Enum.KeyCode.Q, Goal = "KeyPress"}}) end
	conn = run.Heartbeat:Connect(function()
		local t = math.clamp((tick() - start) / duration, 0, 1)
		local e = easeCubic(t)
		local curDist = math.clamp(startDist + (gap - startDist) * easeCubic(math.clamp(t * 1.5, 0, 1)), minGap, maxGap)
		local curAngle = startAngle + dirMult * angle * easeCubic(t)
		local targetCurrentPos = targetHrp.Position
		local nextPos = Vector3.new(targetCurrentPos.X + curDist * math.cos(curAngle), targetCurrentPos.Y, targetCurrentPos.Z + curDist * math.sin(curAngle))
		local lookTarget = targetCurrentPos or nextPos
		local lookAngle = math.atan2((lookTarget - nextPos).Z, (lookTarget - nextPos).X)
		local camAngle = math.atan2(hrp.CFrame.LookVector.Z, hrp.CFrame.LookVector.X)
		local finalAngle = camAngle + (lookAngle-camAngle)* 0.7
		pcall(function() hrp.CFrame = CFrame.new(nextPos, nextPos + Vector3.new(math.cos(finalAngle), 0, math.sin(finalAngle))) end)
		if not aimed and aspect <= e then aimed = true cleanup() end
		if t >= 1 then conn:Disconnect() pcall(function() if sideAnim and sideAnim.IsPlaying then sideAnim:Stop() end sideAnim = nil end) if not aimed then aimed = true cleanup() end endQueued = true if canEnd then isDashing = false end end
	end)
end

-- END SNIPPET 1 (settings logic and all dash/target mechanics implemented)
-- Side Dash Assist v1.0 by CPS Network
-- SNIPPET 2: Sleek black&red curved GUI with working settings, red circular button, custom cross

local function makeDraggable(gui)
	local dragging = false
	local dragStart, startPos, currentInput
	gui.InputBegan:Connect(function(inp)
		if (inp.UserInputType == Enum.UserInputType.Touch or inp.UserInputType == Enum.UserInputType.MouseButton1) and not dragging then
			dragging = true
			dragStart = inp.Position
			startPos = gui.Position
			currentInput = inp
			inp.Changed:Connect(function()
				if inp.UserInputState == Enum.UserInputState.End then dragging = false currentInput = nil end
			end)
		end
	end)
	game:GetService("UserInputService").InputChanged:Connect(function(inp)
		if dragging and currentInput == inp and (inp.UserInputType == Enum.UserInputType.Touch or inp.UserInputType == Enum.UserInputType.MouseMovement) then
			local delta = inp.Position - dragStart
			gui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end)
end

local settingsGui = Instance.new("ScreenGui")
settingsGui.Name = "SideDashAssistGUI"
settingsGui.ResetOnSpawn = false
settingsGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 380, 0, 210)
mainFrame.Position = UDim2.new(0.5, -190, 0.13, 0)
mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = settingsGui
makeDraggable(mainFrame)

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 20)
mainCorner.Parent = mainFrame

local mainBgGradient = Instance.new("UIGradient")
mainBgGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 5, 5)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(15, 15, 15)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
})
mainBgGradient.Rotation = 90
mainBgGradient.Parent = mainFrame

local borderFrame = Instance.new("Frame")
borderFrame.Name = "BorderFrame"
borderFrame.Size = UDim2.new(1, 8, 1, 8)
borderFrame.Position = UDim2.new(0, -4, 0, -4)
borderFrame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
borderFrame.BorderSizePixel = 0
borderFrame.ZIndex = 0
borderFrame.Parent = mainFrame

local borderCorner = Instance.new("UICorner")
borderCorner.CornerRadius = UDim.new(0, 24)
borderCorner.Parent = borderFrame

local borderGradient = Instance.new("UIGradient")
borderGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(120, 0, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(26, 26, 26))
})
borderGradient.Rotation = 45
borderGradient.Parent = borderFrame

local headerFrame = Instance.new("Frame")
headerFrame.Size = UDim2.new(1, 0, 0, 48)
headerFrame.BackgroundTransparency = 1
headerFrame.Parent = mainFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(0, 195, 0, 34)
titleLabel.Position = UDim2.new(0, 20, 0, 8)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Side Dash Assist"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 23
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.TextStrokeTransparency = 0.7
titleLabel.Parent = headerFrame

local versionLabel = Instance.new("TextLabel")
versionLabel.Size = UDim2.new(0, 55, 0, 20)
versionLabel.Position = UDim2.new(0, 218, 0, 13)
versionLabel.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
versionLabel.BorderSizePixel = 0
versionLabel.Text = "v1.0"
versionLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
versionLabel.TextSize = 13
versionLabel.Font = Enum.Font.GothamBold
versionLabel.Parent = headerFrame
local versionCorner = Instance.new("UICorner")
versionCorner.CornerRadius = UDim.new(0, 8)
versionCorner.Parent = versionLabel

-- Proper curved white cross in top right
local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 37, 0, 37)
closeBtn.Position = UDim2.new(1, -51, 0, 6)
closeBtn.BackgroundColor3 = Color3.fromRGB(255,255,255)
closeBtn.Text = "✕"
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextColor3 = Color3.fromRGB(0,0,0)
closeBtn.TextSize = 20
closeBtn.BorderSizePixel = 0
closeBtn.Parent = mainFrame
local closeBtnCorner = Instance.new("UICorner")
closeBtnCorner.CornerRadius = UDim.new(0, 12)
closeBtnCorner.Parent = closeBtn
closeBtn.MouseButton1Click:Connect(function()
	mainFrame.Visible = false
end)

local settingsPanel = Instance.new("Frame")
settingsPanel.Name = "SettingsPanel"
settingsPanel.Size = UDim2.new(1, -24, 0, 110)
settingsPanel.Position = UDim2.new(0,12,0,54)
settingsPanel.BackgroundTransparency = 1
settingsPanel.Parent = mainFrame

-- Toggles (M1 and Dash)
local m1Toggle = Instance.new("TextButton")
m1Toggle.Size = UDim2.new(0, 74, 0, 33)
m1Toggle.Position = UDim2.new(0,0,0,0)
m1Toggle.BackgroundColor3 = Color3.fromRGB(36,36,36)
m1Toggle.Text = "M1"
m1Toggle.TextColor3 = Color3.fromRGB(255,255,255)
m1Toggle.Font = Enum.Font.GothamBold
m1Toggle.TextSize = 17
m1Toggle.Parent = settingsPanel
local m1TogCorner = Instance.new("UICorner")
m1TogCorner.CornerRadius = UDim.new(0,10)
m1TogCorner.Parent = m1Toggle
local m1Dot = Instance.new("Frame", m1Toggle)
m1Dot.Size = UDim2.new(0,14,0,14)
m1Dot.Position = UDim2.new(1,-20,0.5,-7)
m1Dot.BackgroundColor3 = m1Enabled and Color3.fromRGB(190,0,0) or Color3.fromRGB(70,70,70)
Instance.new("UICorner", m1Dot).CornerRadius = UDim.new(1,0)
local function setM1(val)
	m1Enabled = val
	m1Dot.BackgroundColor3 = val and Color3.fromRGB(190,0,0) or Color3.fromRGB(70,70,70)
	m1Toggle.BackgroundColor3 = val and Color3.fromRGB(45,5,5) or Color3.fromRGB(36,36,36)
end
m1Toggle.MouseButton1Click:Connect(function() setM1(not m1Enabled) end)
setM1(m1Enabled)

local dashToggle = Instance.new("TextButton")
dashToggle.Size = UDim2.new(0, 74, 0, 33)
dashToggle.Position = UDim2.new(0,80,0,0)
dashToggle.BackgroundColor3 = Color3.fromRGB(36,36,36)
dashToggle.Text = "Dash"
dashToggle.TextColor3 = Color3.fromRGB(255,255,255)
dashToggle.Font = Enum.Font.GothamBold
dashToggle.TextSize = 17
dashToggle.Parent = settingsPanel
local dashTogCorner = Instance.new("UICorner")
dashTogCorner.CornerRadius = UDim.new(0,10)
dashTogCorner.Parent = dashToggle
local dashDot = Instance.new("Frame", dashToggle)
dashDot.Size = UDim2.new(0,14,0,14)
dashDot.Position = UDim2.new(1,-20,0.5,-7)
dashDot.BackgroundColor3 = dashEnabled and Color3.fromRGB(190,0,0) or Color3.fromRGB(70,70,70)
Instance.new("UICorner", dashDot).CornerRadius = UDim.new(1,0)
local function setDash(val)
	dashEnabled = val
	dashDot.BackgroundColor3 = val and Color3.fromRGB(190,0,0) or Color3.fromRGB(70,70,70)
	dashToggle.BackgroundColor3 = val and Color3.fromRGB(45,5,5) or Color3.fromRGB(36,36,36)
end
dashToggle.MouseButton1Click:Connect(function() setDash(not dashEnabled) end)
setDash(dashEnabled)

-- Sliders for dash speed, degree, gap
local sliderNames = {"Dash speed","Dash Degrees","Dash gap"}
local sliderDefaults = {["Dash speed"]=49,["Dash Degrees"]=32,["Dash gap"]=14}
local sliderUi = {}
for idx, name in ipairs(sliderNames) do
	local group = Instance.new("Frame")
	group.Size = UDim2.new(0,115,0,31)
	group.Position = UDim2.new(0,164,0,(idx-1)*36)
	group.BackgroundTransparency = 1
	group.Parent = settingsPanel
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(0,92,0,18)
	label.Position = UDim2.new(0,0,0,3)
	label.BackgroundTransparency = 1
	label.Text = name
	label.TextColor3 = Color3.fromRGB(160,110,110)
	label.Font = Enum.Font.Gotham
	label.TextSize = 13
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = group
	local bar = Instance.new("Frame")
	bar.Size = UDim2.new(0,74,0,6)
	bar.Position = UDim2.new(0,8,0,23)
	bar.BackgroundColor3 = Color3.fromRGB(46,46,46)
	bar.Parent = group
	Instance.new("UICorner", bar).CornerRadius = UDim.new(1,0)
	local handle = Instance.new("TextButton")
	handle.Size = UDim2.new(0,17,0,17)
	handle.Position = UDim2.new(sliderDefaults[name]/100, -8, 0.5, -8)
	handle.BackgroundColor3 = Color3.fromRGB(160,0,0)
	handle.Text = ""
	handle.ZIndex = 2 handle.AutoButtonColor = false
	handle.Parent = group
	Instance.new("UICorner", handle).CornerRadius = UDim.new(1,0)
	local dragging = false
	local function setValue(x)
		local rel = math.clamp((x-bar.AbsolutePosition.X)/bar.AbsoluteSize.X, 0, 1)
		handle.Position = UDim2.new(rel,-8,0.5,-8)
		sliderVals[name] = math.floor(rel*100)
	end
	handle.InputBegan:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then dragging = true setValue(inp.Position.X) end
	end)
	handle.InputEnded:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then dragging = false end
	end)
	bar.InputBegan:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then dragging = true setValue(inp.Position.X) end
	end)
	bar.InputEnded:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then dragging = false end
	end)
	input.InputChanged:Connect(function(inp)
		if dragging and inp.Position then setValue(inp.Position.X) end
	end)
	sliderVals[name] = sliderDefaults[name]
	sliderUi[name] = handle
end

-- Functional red circular dash button with full gradient, triggers correct dash logic
local dashButtonGui = Instance.new("ScreenGui")
dashButtonGui.Name = "DashButtonGui"
dashButtonGui.ResetOnSpawn = false
dashButtonGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local dashBtn = Instance.new("ImageButton")
dashBtn.Name = "DashButton"
dashBtn.Size = UDim2.new(0, 110, 0, 110)
dashBtn.Position = UDim2.new(0.85, -55, 0.75, -55)
dashBtn.BackgroundTransparency = 1
dashBtn.BorderSizePixel = 0
dashBtn.Image = ""
dashBtn.Visible = true
dashBtn.Parent = dashButtonGui

local dashBtnBg = Instance.new("Frame")
dashBtnBg.Size = UDim2.new(1, 0, 1, 0)
dashBtnBg.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
dashBtnBg.BorderSizePixel = 0
dashBtnBg.ZIndex = 0
dashBtnBg.Parent = dashBtn

local dashBtnCorner = Instance.new("UICorner")
dashBtnCorner.CornerRadius = UDim.new(1, 0)
dashBtnCorner.Parent = dashBtn

local dashBtnCorner2 = Instance.new("UICorner")
dashBtnCorner2.CornerRadius = UDim.new(1, 0)
dashBtnCorner2.Parent = dashBtnBg

local dashBtnGradient = Instance.new("UIGradient")
dashBtnGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 30, 30)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(200, 0, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(80, 0, 0))
})
dashBtnGradient.Rotation = 45
dashBtnGradient.Parent = dashBtnBg

local dashBtnStroke = Instance.new("UIStroke")
dashBtnStroke.Color = Color3.fromRGB(255, 0, 0)
dashBtnStroke.Thickness = 3
dashBtnStroke.Transparency = 0.3
dashBtnStroke.Parent = dashBtn

local dashScale = Instance.new("UIScale")
dashScale.Scale = 1
dashScale.Parent = dashBtn

makeDraggable(dashBtn)

local dashBtnDragging, dashBtnDragStart, dashBtnCurrentInput = false, nil, nil
dashBtn.InputBegan:Connect(function(inp)
	if (inp.UserInputType == Enum.UserInputType.Touch or inp.UserInputType == Enum.UserInputType.MouseButton1) and not dashBtnDragging then
		dashBtnDragging = true
		dashBtnDragStart = inp.Position
		dashBtnCurrentInput = inp
		tween:Create(dashScale, TweenInfo.new(0.08), {Scale = 0.90}):Play()
	end
end)
dashBtn.InputEnded:Connect(function(inp)
	if inp == dashBtnCurrentInput then
		tween:Create(dashScale, TweenInfo.new(0.08), {Scale = 1}):Play()
		if dashBtnDragging and dashBtnDragStart and (inp.Position - dashBtnDragStart).Magnitude < 10 and tick()-lastDash>=1 then
			if not isDead() then
				local target = getCurrentTarget()
				if target then circularDash(target) end
			end
		end
		dashBtnDragging, dashBtnCurrentInput = false, nil
	end
end)

input.InputBegan:Connect(function(inp, gp)
	if gp or isDashing or not m1Enabled or isDead() then return end
	local key = input.GamepadEnabled and Enum.KeyCode.DPadUp or Enum.KeyCode.G
	local shouldDash = false
	if inp.UserInputType == Enum.UserInputType.Keyboard and inp.KeyCode and (inp.KeyCode == Enum.KeyCode.X or inp.KeyCode == key) then
		shouldDash = true
	end
	if shouldDash and tick() - lastDash >= 1 then
		local target = getCurrentTarget()
		if target then circularDash(target) end
	end
end)

print("✅ Side Dash Assist v1.0 - Custom GUI + Full settings options + working dash!")
-- END SNIPPET 2 (all GUI, functional toggles/sliders/close/dash, full black&red theme)
