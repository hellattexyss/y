-- Modern Black & Red GUI Template with Side Dash Assist integration (Snippet 1)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")

local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local humanoid = character:FindFirstChildOfClass("Humanoid")

local cam = Workspace.CurrentCamera
math.randomseed(tick() % 65536)

-- Hardcoded default settings from original script 
local dashRange = 40
local minGap = 1.2
local maxGap = 60
local targetDist = 15
local straightSpeed = 120

local isDashing = false
local lastDash = -math.huge

-- Utility functions from the original script simplified:
local function isDead()
	if not humanoid or not humanoid.Parent then return false end
	if humanoid.Health <= 0 then return true end
	if humanoid.PlatformStand then return true end
	local success, state = pcall(function() return humanoid:GetState() end)
	if success and state == Enum.HumanoidStateType.Physics then return true end
	local ragdoll = character:FindFirstChild("Ragdoll")
	if ragdoll and typeof(ragdoll.Value) == "boolean" and ragdoll.Value then return true end
	return false
end

local function findTarget(range)
	local closest = nil
	local closestDist = math.huge
	local myPos = hrp.Position
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChildOfClass("Humanoid") then
			local targetHum = player.Character:FindFirstChildOfClass("Humanoid")
			if targetHum and targetHum.Health > 0 then
				local dist = (player.Character.HumanoidRootPart.Position - myPos).Magnitude
				if dist < closestDist and dist <= range then
					closest = player.Character
					closestDist = dist
				end
			end
		end
	end
	return closest
end

local function doDash(target)
	if isDashing or not target or not target:FindFirstChild("HumanoidRootPart") then return end
	isDashing = true

	local targetHrp = target.HumanoidRootPart
	local startPos = hrp.Position

	-- Move instantly towards the target at fixed speed, simplified from original dash logic
	-- Could use Tween or linear interpolation for smooth dash, here simplified to instant CFrame move
	hrp.CFrame = CFrame.new(targetHrp.Position)

	wait(0.3) -- dash duration placeholder

	isDashing = false
	lastDash = tick()
end

-- Custom GUI code starts here

local settingsGui = Instance.new("ScreenGui")
settingsGui.Name = "SideDashAssistGUI"
settingsGui.ResetOnSpawn = false
settingsGui.Parent = localPlayer:WaitForChild("PlayerGui")

local function makeDraggable(gui)
	local dragging = false
	local dragStart, startPos, currentInput
	gui.InputBegan:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1) and not dragging then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			currentInput = input
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
					currentInput = nil
				end
			end)
		end
	end)
	UserInputService.InputChanged:Connect(function(input)
		if dragging and currentInput == input and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
			local delta = input.Position - dragStart
			gui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end)
end

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 380, 0, 140)
mainFrame.Position = UDim2.new(0.5, -190, 0.12, 0)
mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = settingsGui
makeDraggable(mainFrame)

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 20)
mainCorner.Parent = mainFrame

local mainBgGradient = Instance.new("UIGradient")
mainBgGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 5, 5)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(15, 15, 15)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
})
mainBgGradient.Rotation = 90
mainBgGradient.Parent = mainFrame

local borderFrame = Instance.new("Frame")
borderFrame.Size = UDim2.new(1, 8, 1, 8)
borderFrame.Position = UDim2.new(0, -4, 0, -4)
borderFrame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
borderFrame.BorderSizePixel = 0
borderFrame.ZIndex = 0
borderFrame.Parent = mainFrame

local borderCorner = Instance.new("UICorner")
borderCorner.CornerRadius = UDim.new(0, 24)
borderCorner.Parent = borderFrame

local borderGradient = Instance.new("UIGradient")
borderGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(120, 0, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(26, 26, 26))
})
borderGradient.Rotation = 45
borderGradient.Parent = borderFrame

-- GUI Header elements
local headerFrame = Instance.new("Frame")
headerFrame.Size = UDim2.new(1, 0, 0, 50)
headerFrame.BackgroundTransparency = 1
headerFrame.Parent = mainFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(0, 190, 0, 30)
titleLabel.Position = UDim2.new(0, 20, 0, 10)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Side Dash Assist"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 23
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.TextStrokeTransparency = 0.7
titleLabel.Parent = headerFrame

local versionLabel = Instance.new("TextLabel")
versionLabel.Size = UDim2.new(0, 55, 0, 24)
versionLabel.Position = UDim2.new(0, 215, 0, 13)
versionLabel.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
versionLabel.BorderSizePixel = 0
versionLabel.Text = "v1.0"
versionLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
versionLabel.TextSize = 13
versionLabel.Font = Enum.Font.GothamBold
versionLabel.Parent = headerFrame

local versionCorner = Instance.new("UICorner")
versionCorner.CornerRadius = UDim.new(0, 8)
versionCorner.Parent = versionLabel

local authorLabel = Instance.new("TextLabel")
authorLabel.Size = UDim2.new(1, -40, 0, 17)
authorLabel.Position = UDim2.new(0, 20, 0, 32)
authorLabel.BackgroundTransparency = 1
authorLabel.Text = "by CPS Network"
authorLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
authorLabel.TextSize = 13
authorLabel.Font = Enum.Font.GothamMedium
authorLabel.TextXAlignment = Enum.TextXAlignment.Left
authorLabel.TextTransparency = 0.28
authorLabel.Parent = headerFrame

-- Close button
local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 35, 0, 35)
closeBtn.Position = UDim2.new(1, -45, 0, 7)
closeBtn.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
closeBtn.Text = "X"
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
closeBtn.TextSize = 19
closeBtn.BorderSizePixel = 0
closeBtn.Parent = mainFrame
local closeBtnCorner = Instance.new("UICorner")
closeBtnCorner.CornerRadius = UDim.new(0, 10)
closeBtnCorner.Parent = closeBtn
closeBtn.MouseButton1Click:Connect(function()
	mainFrame.Visible = false
end)

-- Enable/Disable Button
local buttonContainer = Instance.new("Frame")
buttonContainer.Size = UDim2.new(0, 200, 0, 48)
buttonContainer.Position = UDim2.new(0.5, -100, 0, 72)
buttonContainer.BackgroundTransparency = 1
buttonContainer.Parent = mainFrame

local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(1, 0, 1, 0)
toggleButton.BackgroundTransparency = 1
toggleButton.BorderSizePixel = 0
toggleButton.Text = "Dash Assist: ON"
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.TextSize = 20
toggleButton.Font = Enum.Font.GothamBold
toggleButton.AutoButtonColor = false
toggleButton.ZIndex = 2
toggleButton.Parent = buttonContainer

local buttonBg = Instance.new("Frame")
buttonBg.Size = UDim2.new(1, 0, 1, 0)
buttonBg.BackgroundColor3 = Color3.fromRGB(180, 13, 19)
buttonBg.BorderSizePixel = 0
buttonBg.ZIndex = 1
buttonBg.Parent = buttonContainer

local buttonCorner = Instance.new("UICorner")
buttonCorner.CornerRadius = UDim.new(0, 12)
buttonCorner.Parent = buttonBg

local buttonGradient = Instance.new("UIGradient")
buttonGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(180, 13, 19)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 0, 0))
})
buttonGradient.Rotation = 90
buttonGradient.Parent = buttonBg

local buttonBorder = Instance.new("UIStroke")
buttonBorder.Color = Color3.fromRGB(255, 0, 0)
buttonBorder.Thickness = 2
buttonBorder.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
buttonBorder.Parent = buttonBg

-- BUTTON FUNCTIONALITY
local dashEnabled = true
local Tween = TweenService

local function updateToggleAppearance()
	if dashEnabled then
		toggleButton.Text = "Dash Assist: ON"
		buttonBorder.Color = Color3.fromRGB(255, 0, 0)
		Tween:Create(buttonGradient, TweenInfo.new(0.3), {
			Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(180, 13, 19)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 0, 0))
			})
		}):Play()
	else
		toggleButton.Text = "Dash Assist: OFF"
		buttonBorder.Color = Color3.fromRGB(110, 110, 110)
		Tween:Create(buttonGradient, TweenInfo.new(0.3), {
			Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(54, 54, 54)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(27, 27, 27))
			})
		}):Play()
	end
end

toggleButton.MouseButton1Click:Connect(function()
	dashEnabled = not dashEnabled
	updateToggleAppearance()
end)

updateToggleAppearance()

-- DASH BUTTON with red circle gradient instead of image
local dashGui = Instance.new("ScreenGui")
dashGui.Name = "DashButtonGui"
dashGui.ResetOnSpawn = false
dashGui.Parent = localPlayer:WaitForChild("PlayerGui")

local dashButton = Instance.new("ImageButton")
dashButton.Name = "DashButton"
dashButton.Size = UDim2.new(0, 110, 0, 110)
dashButton.Position = UDim2.new(0.5, -55, 0.8, -55)
dashButton.BackgroundTransparency = 1
dashButton.BorderSizePixel = 0
dashButton.Parent = dashGui

-- Red circular gradient for dash button
local circleFrame = Instance.new("Frame")
circleFrame.Size = UDim2.new(1, 0, 1, 0)
circleFrame.Parent = dashButton
circleFrame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
circleFrame.BorderSizePixel = 0
circleFrame.AnchorPoint = Vector2.new(0.5, 0.5)
circleFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
circleFrame.ClipsDescendants = true
local circleCorner = Instance.new("UICorner")
circleCorner.CornerRadius = UDim.new(1, 0)
circleCorner.Parent = circleFrame

local circleGradient = Instance.new("UIGradient")
circleGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 50, 50)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(180, 0, 0))
})
circleGradient.Rotation = 0
circleGradient.Parent = circleFrame

-- Make the circle frame non-interactable, pass inputs to button
circleFrame.Active = false
circleFrame.Selectable = false

local dragging = false
local dragStart, startPos, dragInput

-- Dragging functionality for dash button (optional)
dashButton.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		startPos = dashButton.Position
		dragInput = input
		TweenService:Create(dashButton, TweenInfo.new(0.06, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(0, 100, 0, 100)}):Play()
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if dragging and input == dragInput and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
		local delta = input.Position - dragStart
		local newX = math.clamp(startPos.X.Offset + delta.X, 0, cam.ViewportSize.X - dashButton.AbsoluteSize.X)
		local newY = math.clamp(startPos.Y.Offset + delta.Y, 0, cam.ViewportSize.Y - dashButton.AbsoluteSize.Y)
		dashButton.Position = UDim2.new(0, newX, 0, newY)
	end
end)

dashButton.InputEnded:Connect(function(input)
	if dragging and input == dragInput then
		if (input.Position - dragStart).Magnitude < 8 and tick() - lastDash > 2 and dashEnabled and not isDead() then
			local target = findTarget(dashRange)
			if target then
				doDash(target)
			end
		end
		dragging = false
		TweenService:Create(dashButton, TweenInfo.new(0.06, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(0, 110, 0, 110)}):Play()
	end
end)

-- End of snippet 1, implementation of GUI with dash button and associated dash functionality
-- Side Dash Assist input listener and dash logic (Snippet 2)

local UserInputService = game:GetService("UserInputService")

-- Listen for specific inputs to trigger the dash manually
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed or isDashing or not dashEnabled or isDead() then return end
	
	local keyActivated = false

	-- Keyboard keys
	if input.UserInputType == Enum.UserInputType.Keyboard then
		if input.KeyCode == Enum.KeyCode.X or input.KeyCode == Enum.KeyCode.G then
			keyActivated = true
		end
	end
	-- Gamepad buttons
	if input.UserInputType == Enum.UserInputType.Gamepad1 or input.UserInputType == Enum.UserInputType.Gamepad2
		or input.UserInputType == Enum.UserInputType.Gamepad3 or input.UserInputType == Enum.UserInputType.Gamepad4 then
		if input.KeyCode == Enum.KeyCode.DPadUp then
			keyActivated = true
		end
	end

	-- If mouse button down on dash button
	if input.UserInputType == Enum.UserInputType.MouseButton1 and input.Target == nil then
		-- Not triggering dash here; dash button click handled separately already
	end

	if keyActivated then
		local target = findTarget(dashRange)
		if target then
			doDash(target)
		end
	end
end)

-- Additional setup: update humanoid and character references if character respawns
localPlayer.CharacterAdded:Connect(function(char)
	character = char
	hrp = character:WaitForChild("HumanoidRootPart")
	humanoid = character:FindFirstChildOfClass("Humanoid")
end)

-- End of snippet 2, input listening and dash execution

